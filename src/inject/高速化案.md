🎯 主要な高速化案

1. 画像保存時にタイル分割を事前実行 ⭐（最も効果大）

現状の問題：

- splitImageOnTiles が inject 側で毎回実行される
- Canvas API でタイル分割（45-51 行のループ）が重い

提案：
// content.ts で画像保存時に実行
const preSplitAndStore = async (imageKey: string, imageBlob: Blob, coords: WplaceCoords) => {
// 1. 画像を分割
const tiles = await splitImageOnTiles(...);

    // 2. IndexedDB に保存（Chrome storage より大容量）
    await indexedDB.put(`tiles_${imageKey}`, {
      tiles: tiles,  // ImageBitmap を Blob に変換して保存
      coords: coords,
      timestamp: Date.now()
    });

    // 3. inject 側には分割済みのタイルキーのみ送信
    sendPreSplitTilesToInject(imageKey);

};

メリット：

- 描画時の処理が大幅に軽減（分割処理スキップ）
- タイル分割は一度だけ実行
- 初回描画が劇的に速くなる

デメリット：

- ストレージ使用量増加（対策：IndexedDB 使用で問題なし）
- 保存時の処理時間が若干増加（非同期なので UI 影響なし）

---

2. 統計データを画像保存時に計算・保存 ⭐

現状の問題：

- computeStatsForImage は事前計算されているが、毎回ネットワーク fetch が必要
- 背景タイルが時間とともに変わるため、統計が古くなる可能性

提案：
// 画像保存時に統計の max 値を計算・保存
interface PreComputedStats {
totalColors: Record<string, number>; // total は変わらない
timestamp: number;
tilesCount: number;
}

// 保存時
const preComputeStats = async (imageKey: string, tiles: Record<string, ImageBitmap>) => {
const stats = computeTotalColorsOnly(tiles); // matched は計算しない
await storage.set(`stats_${imageKey}`, stats);
};

メリット：

- total（最大値）は背景に依存しないため、保存時に確定できる
- カラーフィルター画面で即座に表示可能
- ネットワーク fetch が不要

デメリット：

- matched（一致数）は背景に依存するため、引き続き動的計算が必要
- ただし、total だけでも表示が大幅に改善される

---

3. ImageBitmap のメモリキャッシュ 🚀

提案：
// inject 側でキャッシュを導入
const imageBitmapCache = new Map<string, ImageBitmap>();

const getCachedImageBitmap = async (dataUrl: string, cacheKey: string): Promise<ImageBitmap> =>
{
if (imageBitmapCache.has(cacheKey)) {
return imageBitmapCache.get(cacheKey)!;
}

    const img = new Image();
    img.src = dataUrl;
    await img.decode();
    const bitmap = await createImageBitmap(img);

    imageBitmapCache.set(cacheKey, bitmap);
    return bitmap;

};

メリット：

- 同じ画像の重複デコードを防止
- メモリ効率的（ImageBitmap は GPU メモリに保存される）

---

4. Web Worker で画像処理を並列化 💡

提案：
// src/workers/image-processor.worker.ts
self.addEventListener('message', async (e) => {
const { type, data } = e.data;

    if (type === 'split-image') {
      const tiles = await splitImageOnTiles(data);
      self.postMessage({ type: 'split-complete', tiles });
    }

    if (type === 'compute-stats') {
      const stats = await computeStatsForImage(data);
      self.postMessage({ type: 'stats-complete', stats });
    }

});

メリット：

- UI スレッドをブロックしない
- 複数画像を並列処理可能

デメリット：

- Worker との通信オーバーヘッド
- ImageBitmap の転送が必要（transferable object を使用）

---

5. OffscreenCanvas で GPU 活用 🔥

提案：
// Web Worker 内で OffscreenCanvas を使用
const offscreenCanvas = new OffscreenCanvas(width, height);
const ctx = offscreenCanvas.getContext('2d');

// GPU で画像合成
ctx.drawImage(backgroundTile, 0, 0);
ctx.drawImage(overlayTile, offsetX, offsetY);

// ImageBitmap に変換
const result = await offscreenCanvas.convertToBlob();

メリット：

- GPU で画像処理が実行される
- Worker と組み合わせで最大効率

---

6. 視覚外タイルの遅延処理 ⚡

提案：
// 現在表示されているタイルのみ処理
const isVisibleTile = (tileX: number, tileY: number, viewport: Bounds): boolean => {
return (
tileX >= viewport.minX && tileX <= viewport.maxX &&
tileY >= viewport.minY && tileY <= viewport.maxY
);
};

// タイル分割時にフィルター
const visibleTiles = Object.entries(allTiles).filter(([key, _]) =>
isVisibleTile(getTileCoords(key), currentViewport)
);

---

📊 効果予測

| 施策                      | 処理時間削減        | 実装難易度 | 優先度 |
| ------------------------- | ------------------- | ---------- | ------ |
| 1. 事前タイル分割         | 80-90%              | 中         | ⭐⭐⭐ |
| 2. 統計事前計算           | 50-70% (total のみ) | 低         | ⭐⭐⭐ |
| 3. ImageBitmap キャッシュ | 30-50%              | 低         | ⭐⭐   |
| 4. Web Worker             | 20-40% (UI 改善)    | 高         | ⭐     |
| 5. OffscreenCanvas        | 10-30%              | 高         | ⭐     |
| 6. 遅延処理               | 50-80% (大量画像時) | 中         | ⭐⭐   |

---

🎯 推奨実装順序

Phase 1（即効性高）:

1. 事前タイル分割 - IndexedDB 導入
2. 統計の total 値事前計算 - storage に保存

Phase 2（改善）: 3. ImageBitmap キャッシュ - メモリ効率化 4. 視覚外タイルの遅延処理 - 大量画像対策

Phase 3（高度）: 5. Web Worker + OffscreenCanvas（必要に応じて）

この順序で実装すると、Phase 1 だけで体感速度が 5-10 倍改善する見込みです。
