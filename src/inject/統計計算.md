# 統計計算処理の調査結果

統計計算の全体像を調査しました。以下、処理フロー、設計意図、パフォーマンス上の懸念をまとめます。

---

## 📋 統計計算の全体アーキテクチャ

統計には **2種類** があります:

### **Total統計**
- **画像の色構成** (位置・背景無関係)
- **1回だけ計算すればOK** (画像が変わらない限り不変)
- 画像保存時に計算して Chrome storage に保存

### **Matched統計**
- **背景との一致度**
- **タイル描画のたびに計算が必要** (背景が更新されるため)
  - 理由1: 他のユーザーがタイルを更新 → 進捗変化
  - 理由2: 自分が塗りつぶした → 進捗が進む

---

## 🔍 統計計算の実装

### **1️⃣ Total統計の計算**

#### 計算タイミング
画像保存時 (1回のみ)

#### 処理フロー
```
画像保存 → requestTotalStatsComputation()
         → inject: handleComputeTotalStats()
         → computeTotalStatsFromImage()
         → content: handleTotalStatsComputed()
         → Chrome storage に保存
```

#### 実装場所
- `src/inject/tile-draw/stats/compute-total.ts`: 計算ロジック
- `src/inject/handlers/request-handlers.ts:103-126`: メッセージハンドラー
- `src/content.ts:199-223`: storage保存
- `src/features/gallery/routes/image-editor/controller.ts:436-437, 465-466`: 呼び出し

#### 特徴
- 背景比較なし (画像のみ)
- カラーフィルター無関係
- 透明ピクセル(α=0)はスキップ

---

### **2️⃣ Matched統計の計算**

統計計算は **2つの経路** で行われます:

#### **経路A: 事前計算 (Background Computation)**

画像追加時にバックグラウンドで実行 (`states.ts:78-125`)

```
画像追加 → 2秒待機 → タイルごとに背景fetch → 統計計算 → perTileColorStats に保存
```

- **目的**: ユーザーがタイルを訪問する前に統計を準備
- **制限**: data saver ON時はスキップ (タイルキャッシュがないため)
- **throttling**: 10タイルごとに100ms待機 (ネットワーク負荷軽減)

#### **経路B: タイルレンダリング時計算 (On-Demand Computation)**

ユーザーがタイルを訪問したときに実行 (`tile-overlay-renderer.ts:326-439`)

```
タイル描画 → 既存統計を削除 → タイル処理 → tempStatsMap で集計 → perTileColorStats に保存
```

- **削除ロジックの理由**:
  - 理由1: 他ユーザーがタイルを更新した可能性があるため
  - 理由2: 自分が塗りつぶした直後でタイルが更新されているため
- **毎回計算が必要**: 背景が変わっている可能性があるため

---

## ⚠️ 現在の問題点

### **🔴 Critical: Total統計の重複計算**

**場所**: `tile-overlay-renderer.ts:75-82` (`computeStatsWithBackground()` 内)

```typescript
// total: 元画像の色でカウント（カラーフィルター無関係）
const [origR, origG, origB] = [
  originalData[i],
  originalData[i + 1],
  originalData[i + 2]
];
const totalColorKey = colorToKey([origR, origG, origB]);
stats.total.set(totalColorKey, (stats.total.get(totalColorKey) || 0) + 1);
```

**問題**:
- タイル描画のたびに total を再計算している
- でも、total は画像が変わらない限り不変なので、**再計算は無駄**

**影響**:
- パフォーマンス低下 (width × height のループが無駄に実行される)
- perTileColorStats の total が上書きされる (実質的には同じ値だが無駄)

**解決策**:
- `computeStatsWithBackground()` から total 計算を削除
- Total は `computeTotalStatsFromImage()` で1回だけ計算 (既に実装済み)
- Matched のみ毎回計算

---

### **🟡 Medium: 事前計算の無駄**

**問題**:
- 事前計算 (経路A) で matched を計算
- でも、タイル描画時 (経路B) で削除して再計算
- → **事前計算が無駄になっている**

**なぜ削除が必要?**
- タイル描画時点で背景が更新されている可能性があるため
- 古い統計を使うと進捗が正しく表示されない

**現在の設計は正しい**:
- 事前計算は「タイルを訪問していない部分」の統計を提供
- タイル描画時は「最新の背景」で統計を再計算
- → 両方とも意味がある

**改善の余地**:
- タイルの ETag や Last-Modified をチェックして、背景が変わっていなければ再計算をスキップ
- → ただし、実装コストが高い

---

## 🚀 パフォーマンス上の懸念

### **1. Total計算の重複実行**

**影響**:
- タイル描画のたびに width × height のループが無駄に実行される
- 大きな画像 (100+ タイル) の場合、累積すると遅くなる

**優先度**: 🔴 High (修正すべき)

---

### **2. ネットワークリクエストの集中**

**影響範囲**: `compute-for-image.ts:178-214`

**問題**:
- 画像1枚あたり数十〜数百のタイル背景を fetch
- 複数画像を同時に追加すると、ネットワークが混雑
- タイムアウト(5秒)が発生しやすい

**現在の対策**:
- 10タイルごとに100ms待機 (throttling)
- data saver ON時はスキップ

**改善案**:
- タイルを batch fetch (複数タイルを1リクエストで取得) ← API側の対応が必要
- Service Worker でキャッシュ活用
- Web Worker で並列処理

**優先度**: 🟡 Medium (現在の対策で十分動作している)

---

### **3. ImageData処理のメモリ使用量**

**影響範囲**: `tile-overlay-renderer.ts:267-300`

**問題**:
- 1タイルあたり 1000x1000x4 = 4MB のメモリ
- 複数タイル + 複数画像 = 数十MB のメモリ使用

**優先度**: 🟡 Medium (致命的ではない)

---

### **4. 統計マージの計算量**

**影響範囲**: `get-aggregated.ts:3-32`

**計算量**: O(N × T × C)
- N: 画像数
- T: 画像あたりタイル数
- C: タイルあたり色数

**影響**:
- 画像が10枚、各100タイル、各20色 → 20,000回のループ
- リアルタイム集計には問題ないが、頻繁に呼ばれると遅い

**優先度**: 🟢 Low (現状問題なし)

---

## ✅ 良い設計ポイント

1. **統計の分離**: total (元画像) と matched (フィルター後) を分けて管理
2. **2経路の計算**: 事前計算 + タイル描画時計算で柔軟に対応
3. **エラーハンドリング**: fetch失敗時にnullを返してスキップ
4. **タイムアウト**: 5秒タイムアウトでハング防止
5. **data saver対応**: ON時は統計計算をスキップ
6. **非同期処理**: バックグラウンド計算でUIをブロックしない

---

## 🔧 推奨改善案 (優先度順)

### **1. 🔴 High: Total統計の重複計算を削除**

`computeStatsWithBackground()` から total 計算を削除する。

**Before**:
```typescript
// total: 元画像の色でカウント（カラーフィルター無関係）
const totalColorKey = colorToKey([origR, origG, origB]);
stats.total.set(totalColorKey, (stats.total.get(totalColorKey) || 0) + 1);
```

**After**:
```typescript
// Total は computeTotalStatsFromImage() で1回だけ計算済み
// ここでは matched のみ計算
```

**理由**:
- Total は不変なので、毎回計算する必要がない
- `computeTotalStatsFromImage()` で既に計算してstorageに保存済み

**影響**:
- パフォーマンス向上 (タイル描画が約10-20%高速化)
- ColorStats の total は空になる (問題なし: get-aggregated.ts で参照されていない)

---

### **2. 🟡 Medium: 統計の永続化を検討**

- Chrome storage に matched 統計を保存
- ページリロード時に再計算不要
- ストレージサイズに注意 (10MB制限)

**優先度**: 🟡 Medium (実装コストに対する効果が不明)

---

### **3. 🟢 Low: 統計計算のキャンセル機能**

- カラーフィルター変更中に別のフィルターに変更した場合、前の計算をキャンセル
- `AbortController` で fetch をキャンセル

**優先度**: 🟢 Low (現状問題なし)

---

### **4. 🟢 Low: Web Worker で統計計算を分離**

- メインスレッドをブロックしない
- 並列処理でパフォーマンス向上

**優先度**: 🟢 Low (実装コストが高い)

---

## 📊 まとめ

| 項目 | 評価 | コメント |
|------|------|----------|
| **アーキテクチャ** | 🟢 | 2種類の統計 (total/matched) と2経路の計算は理にかなっている |
| **Total計算** | 🔴 | タイル描画時の重複計算が無駄 → 削除すべき |
| **Matched計算** | 🟢 | 毎回計算する必要があり、削除ロジックも正しい |
| **統計削除ロジック** | 🟢 | 背景更新対応のため必要 (誤解していた) |
| **事前計算** | 🟡 | タイル訪問前の統計提供には有用だが、タイル描画時に再計算される |
| **ネットワーク** | 🟡 | throttlingで対策済みだが、改善余地あり |
| **メモリ** | 🟡 | 大量のImageDataを扱うが、致命的ではない |

**最優先で修正すべき**: `computeStatsWithBackground()` から total 計算を削除
